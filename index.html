<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>Ø¬ÙˆÙ„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="style.css">

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>

<div class="info">ğŸ—ï¸ Virtual Tour</div>
<div id="container"></div>
<button id="autoRotateBtn">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯ÙˆØ±Ø§Ù†</button>

<script>
/* ================== Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ================== */
let scene, camera, renderer, controls;
let sphereMesh;
let scenesData = [];
let currentSceneIndex = 0;
let autoRotate = true;
let hotspotElements = [];

/* ================== ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬ÙˆÙ„Ø© ================== */
fetch('tour-data.json')
.then(res => res.json())
.then(data => {
    scenesData = data;
    init();
    loadScene(0);
    animate();
});

/* ================== Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ================== */
function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
    );
    camera.position.set(0, 0, 0.1);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = true;
    controls.enableDamping = true;
    controls.autoRotate = autoRotate;
    controls.autoRotateSpeed = 0.4;

    document.getElementById('autoRotateBtn').onclick = () => {
        autoRotate = !autoRotate;
        controls.autoRotate = autoRotate;
        document.getElementById('autoRotateBtn').innerText =
            autoRotate ? 'â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯ÙˆØ±Ø§Ù†' : 'â–¶ï¸ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¯ÙˆØ±Ø§Ù†';
    };

    window.addEventListener('resize', onResize);
}

/* ================== ØªØ­Ù…ÙŠÙ„ Ù…Ø´Ù‡Ø¯ ================== */
function loadScene(index) {
    const data = scenesData[index];
    if (!data) return;
    currentSceneIndex = index;

    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù€ sphere Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
    if (sphereMesh) scene.remove(sphereMesh);

    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù€ hotspots
    hotspotElements.forEach(h => h.remove());
    hotspotElements = [];

    new THREE.TextureLoader().load(data.image, texture => {
        texture.wrapS = THREE.RepeatWrapping;
        texture.repeat.x = -1;

        const geometry = new THREE.SphereGeometry(500, 128, 128);
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.BackSide
        });

        sphereMesh = new THREE.Mesh(geometry, material);
        scene.add(sphereMesh);

        // Ø¥Ù†Ø´Ø§Ø¡ hotspots
        data.hotspots.forEach(createHotspot);
    });
}

/* ================== Ø¥Ù†Ø´Ø§Ø¡ Hotspot ================== */
function createHotspot(hotspot) {
    const el = document.createElement('div');
    el.className = 'hotspot';

    el.dataset.x = hotspot.position.x;
    el.dataset.y = hotspot.position.y;
    el.dataset.z = hotspot.position.z;
    el.dataset.type = hotspot.type;
    el.dataset.data = JSON.stringify(hotspot.data);

    if (hotspot.type === 'INFO') {
        el.style.color = '#ffaa44';
        el.innerHTML = `
            <span class="hotspot-icon">â„¹ï¸</span>
            <div class="hotspot-tooltip">
                <strong>${hotspot.data.title}</strong>
                <p>${hotspot.data.content}</p>
            </div>
        `;
    } else {
        el.style.color = '#44aaff';
        el.innerHTML = `
            <span class="hotspot-icon">ğŸšª</span>
            <div class="hotspot-tooltip">
                <strong>Ø§Ù†ØªÙ‚Ø§Ù„</strong>
                <p>${hotspot.data.description}</p>
            </div>
        `;
        el.onclick = () => {
            const target = scenesData.findIndex(
                s => s.id === hotspot.data.targetSceneId
            );
            if (target !== -1) loadScene(target);
        };
    }

    document.body.appendChild(el);
    hotspotElements.push(el);
}

/* ================== Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙˆØ§Ù„Ø±Ø³Ù… ================== */
function animate() {
    requestAnimationFrame(animate);
    controls.update();

    hotspotElements.forEach(el => {
        const x = parseFloat(el.dataset.x);
        const y = parseFloat(el.dataset.y);
        const z = parseFloat(el.dataset.z);

        const vector = new THREE.Vector3(x, y, z).project(camera);

        if (vector.z > 1) {
            el.style.display = 'none';
            return;
        }

        el.style.display = 'block';
        el.style.left = (vector.x * 0.5 + 0.5) * window.innerWidth + 'px';
        el.style.top = (-vector.y * 0.5 + 0.5) * window.innerHeight + 'px';
    });

    renderer.render(scene, camera);
}

/* ================== Resize ================== */
function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>

</body>
</html>
