<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8">
<title>Ø¬ÙˆÙ„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="style.css">

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>

<div id="container"></div>

<div class="info">ğŸ—ï¸ Ø¬ÙˆÙ„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©</div>

<div id="sceneMenu"></div>

<script>
/* ========== Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© ========== */
let scene, camera, renderer, controls;
let sphere;
let scenesData = [];
let hotspots = [];

/* ========== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ========== */
fetch('tour-data.json')
.then(r => r.json())
.then(data => {
    scenesData = data;
    init();
    buildMenu();
    loadScene(0);
    animate();
});

/* ========== Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ========== */
function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
    );
    camera.position.set(0, 0, 0.1);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = true;
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.6;

    window.addEventListener('resize', onResize);
}

/* ========== ØªØ­Ù…ÙŠÙ„ Ù…Ø´Ù‡Ø¯ ========== */
function loadScene(index) {
    const data = scenesData[index];
    if (!data) return;

    if (sphere) scene.remove(sphere);
    hotspots.forEach(h => h.remove());
    hotspots = [];

    new THREE.TextureLoader().load(data.image, tex => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.repeat.x = -1;

        sphere = new THREE.Mesh(
            new THREE.SphereGeometry(500, 128, 128),
            new THREE.MeshBasicMaterial({
                map: tex,
                side: THREE.BackSide
            })
        );
        scene.add(sphere);

        controls.target.set(0, 0, -1);
        controls.update();

        data.hotspots.forEach(createHotspot);
    });
}

/* ========== Ø¥Ù†Ø´Ø§Ø¡ Hotspot ========== */
function createHotspot(h) {
    const el = document.createElement('div');
    el.className = 'hotspot';

    el.dataset.x = h.position.x;
    el.dataset.y = h.position.y;
    el.dataset.z = h.position.z;
    el.dataset.type = h.type;
    el.dataset.data = JSON.stringify(h.data);

    if (h.type === 'INFO') {
        el.innerHTML = `
            <span class="icon">â„¹ï¸</span>
            <div class="tooltip">
                <strong>${h.data.title}</strong>
                <p>${h.data.content}</p>
            </div>
        `;
    } else {
        el.innerHTML = `
            <span class="icon">ğŸšª</span>
            <div class="tooltip">${h.data.description}</div>
        `;
        el.onclick = () => {
            const i = scenesData.findIndex(s => s.id === h.data.targetSceneId);
            if (i !== -1) loadScene(i);
        };
    }

    document.body.appendChild(el);
    hotspots.push(el);
}

/* ========== Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© ========== */
function buildMenu() {
    const menu = document.getElementById('sceneMenu');
    scenesData.forEach((s, i) => {
        const btn = document.createElement('button');
        btn.textContent = s.name || `Ù…Ø´Ù‡Ø¯ ${i + 1}`;
        btn.onclick = () => loadScene(i);
        menu.appendChild(btn);
    });
}

/* ========== Ø§Ù„ØªØ­Ø¯ÙŠØ« ========== */
function animate() {
    requestAnimationFrame(animate);
    controls.update();

    hotspots.forEach(el => {
        const v = new THREE.Vector3(
            el.dataset.x,
            el.dataset.y,
            el.dataset.z
        ).project(camera);

        if (v.z < -1 || v.z > 1) {
            el.style.display = 'none';
            return;
        }

        el.style.display = 'block';
        el.style.left = (v.x * 0.5 + 0.5) * window.innerWidth + 'px';
        el.style.top  = (-v.y * 0.5 + 0.5) * window.innerHeight + 'px';
    });

    renderer.render(scene, camera);
}

/* ========== Resize ========== */
function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>

</body>
</html>
